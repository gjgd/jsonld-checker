{"version":3,"sources":["models/CheckStatus.ts","components/JsonEditor.tsx","components/JsonLdPlaygroundButton.tsx","components/CheckJsonButton.tsx","components/CheckResult.tsx","components/CheckJsonTab.tsx","components/ResultTable.tsx","components/CheckFileTab.tsx","components/Tabs.tsx","App.tsx","index.tsx","../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../../src/CheckResult.tsx","../../src/index.ts"],"names":["Status","JsonEditor","onChange","value","index","readOnly","placeholder","width","mode","theme","name","fontSize","showPrintMargin","showGutter","highlightActiveLine","setOptions","enableBasicAutocompletion","enableLiveAutocompletion","enableSnippets","showLineNumbers","tabSize","useStyles","makeStyles","wrapper","margin","spacing","position","JsonLdPlaygroundLink","classes","encodedValue","encodeURIComponent","className","Button","color","variant","href","target","rel","createStyles","root","display","alignItems","buttonSuccess","backgroundColor","green","buttonError","red","buttonProgress","top","left","marginTop","marginLeft","CheckJsonButton","setResult","React","useState","loading","setLoading","success","setSuccess","error","setError","buttonClassname","clsx","useEffect","onClick","a","check","res","ok","disabled","CircularProgress","size","CheckResult","result","Alert","severity","AlertTitle","type","details","defaultValue","JSON","stringify","defaultValueJson","buttonWrapper","contentWrapper","checkResult","marginBottom","CheckJsonTab","jsonValue","setJsonValue","JsonLdPlaygroundButton","undefined","useRowStyles","borderBottom","Row","props","Icon","row","open","setOpen","status","CheckStatus","PASSED","style","FAILED","PENDING","TableRow","TableCell","IconButton","aria-label","component","scope","align","paddingBottom","paddingTop","colSpan","Collapse","in","timeout","unmountOnExit","Box","Typography","gutterBottom","object","key","ResultTable","rows","results","map","id","length","TableContainer","Paper","Table","TableHead","TableBody","defaultUrl","flexWrap","progressBar","textField","marginRight","CheckFileTab","url","setUrl","docs","setDocs","total","setTotal","onClickCheck","fetch","text","getAllJsonLdFromString","jsonldObjects","sleep","ms","Promise","resolve","setTimeout","processed","i","push","errors","filter","doc","hasErrors","errorSentence","TextField","label","event","fullWidth","LinearProgress","TabPanel","children","role","hidden","aria-labelledby","p","a11yProps","flexGrow","palette","background","paper","SimpleTabs","setValue","AppBar","Tabs","newValue","alert","centered","Tab","App","console","log","process","ReactDOM","render","StrictMode","document","getElementById","Symbol","iterator","asyncIterator","this","CONTEXTS","nodeDocumentLoader","jsonld","contextUrl","documentUrl","isNotJsonLdPropery","property","includes","body","recover","e","then","jsonldDoc","jsonldDocument","keys","Object","newKeysSet","Set","difference","err","getAllJsonFromString","cursor","getAllOpenBrackets","openBracketIndex","substring","Error","bracketCount","currentChar","getStringUntilMatchingBracket","obj","isJsonLdObject"],"mappings":"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","file":"static/js/main.5d0af779.chunk.js","sourcesContent":["enum Status {\n  PENDING,\n  PASSED,\n  FAILED,\n  TO_PROCESS,\n}\n\nexport default Status;\n","import React from 'react';\nimport AceEditor from 'react-ace';\nimport 'ace-builds/src-noconflict/ext-language_tools';\nimport 'ace-builds/src-noconflict/mode-json';\nimport 'ace-builds/src-noconflict/theme-monokai';\n\nconst JsonEditor: React.FunctionComponent<{\n  index?: number;\n  onChange?: any;\n  readOnly?: boolean;\n  value: string;\n}> = ({ onChange, value, index, readOnly }) => {\n  return (\n    <AceEditor\n      placeholder=\"Paste your JSON-LD object here\"\n      width=\"800px\"\n      mode=\"json\"\n      theme=\"monokai\"\n      name={`json-ld-editor-${index}`}\n      onChange={onChange}\n      readOnly={readOnly}\n      fontSize={14}\n      showPrintMargin\n      showGutter\n      highlightActiveLine\n      value={value}\n      setOptions={{\n        enableBasicAutocompletion: false,\n        enableLiveAutocompletion: false,\n        enableSnippets: false,\n        showLineNumbers: true,\n        tabSize: 2,\n      }}\n    />\n  );\n};\n\nexport default JsonEditor;\n","import React from 'react';\nimport { makeStyles } from '@material-ui/core/styles';\nimport Button from '@material-ui/core/Button';\n\nconst useStyles = makeStyles((theme) => ({\n  wrapper: {\n    margin: theme.spacing(1),\n    position: 'relative',\n  },\n}));\n\nconst JsonLdPlaygroundLink: React.FunctionComponent<{ value: string }> = ({\n  value,\n}) => {\n  const classes = useStyles();\n  const encodedValue = encodeURIComponent(value);\n  return (\n    <div className={classes.wrapper}>\n      <Button\n        color=\"primary\"\n        variant=\"contained\"\n        href={`https://json-ld.org/playground/#json-ld=${encodedValue}`}\n        target=\"_blank\"\n        rel=\"noopener\"\n      >\n        Open in JSON-LD Playground\n      </Button>\n    </div>\n  );\n};\n\nexport default JsonLdPlaygroundLink;\n","import React from 'react';\nimport Button from '@material-ui/core/Button';\nimport { check } from 'jsonld-checker';\nimport CircularProgress from '@material-ui/core/CircularProgress';\nimport { green, red } from '@material-ui/core/colors';\nimport { createStyles, makeStyles, Theme } from '@material-ui/core/styles';\nimport clsx from 'clsx';\n\nconst useStyles = makeStyles((theme: Theme) =>\n  createStyles({\n    root: {\n      display: 'flex',\n      alignItems: 'center',\n    },\n    wrapper: {\n      margin: theme.spacing(1),\n      position: 'relative',\n    },\n    buttonSuccess: {\n      backgroundColor: green[500],\n      '&:hover': {\n        backgroundColor: green[700],\n      },\n    },\n    buttonError: {\n      backgroundColor: red[500],\n      '&:hover': {\n        backgroundColor: red[700],\n      },\n    },\n    buttonProgress: {\n      color: green[500],\n      position: 'absolute',\n      top: '50%',\n      left: '50%',\n      marginTop: -12,\n      marginLeft: -12,\n    },\n  })\n);\n\nconst CheckJsonButton: React.FunctionComponent<{\n  value: Object;\n  setResult: any;\n}> = ({ value, setResult }) => {\n  const classes = useStyles();\n  const [loading, setLoading] = React.useState(false);\n  const [success, setSuccess] = React.useState(false);\n  const [error, setError] = React.useState(false);\n\n  const buttonClassname = clsx({\n    [classes.buttonSuccess]: success,\n    [classes.buttonError]: error,\n  });\n\n  React.useEffect(() => {\n    setSuccess(false);\n    setError(false);\n  }, [value]);\n\n  const onClick = async () => {\n    if (!loading) {\n      setLoading(true);\n      const res = await check(value);\n      setSuccess(res.ok);\n      setError(!res.ok);\n      setResult(res);\n      setLoading(false);\n    }\n  };\n\n  return (\n    <div className={classes.root}>\n      {success}\n      {error}\n      <div className={classes.wrapper}>\n        <Button\n          variant=\"contained\"\n          color=\"primary\"\n          className={buttonClassname}\n          disabled={loading}\n          onClick={onClick}\n        >\n          Check\n        </Button>\n        {loading && (\n          <CircularProgress size={24} className={classes.buttonProgress} />\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default CheckJsonButton;\n","import React from 'react';\nimport { Alert, AlertTitle } from '@material-ui/lab';\nimport { CheckResult as JsonLdCheckResult } from 'jsonld-checker';\n\nconst CheckResult: React.FunctionComponent<{\n  result: JsonLdCheckResult | undefined;\n  className?: any;\n}> = ({ result, className }) => {\n  if (!result) {\n    return <></>;\n  }\n  if (result.ok) {\n    return <Alert severity=\"success\">All Good!</Alert>;\n  }\n  return (\n    <Alert className={className} severity=\"error\">\n      <AlertTitle>{result.error!.type}</AlertTitle>\n      {result.error!.details}\n    </Alert>\n  );\n};\n\nexport default CheckResult;\n","import React from 'react';\nimport { makeStyles } from '@material-ui/core/styles';\nimport { CheckResult as JsonLdCheckResult } from 'jsonld-checker';\nimport JsonEditor from './JsonEditor';\nimport JsonLdPlaygroundButton from './JsonLdPlaygroundButton';\nimport CheckJsonButton from './CheckJsonButton';\nimport defaultValueJson from '../data/defaultValue.json';\nimport CheckResult from './CheckResult';\n\nconst defaultValue = JSON.stringify(defaultValueJson, null, 2);\n\nconst useStyles = makeStyles((theme) => ({\n  buttonWrapper: {\n    display: 'flex',\n    margin: theme.spacing(1),\n  },\n  contentWrapper: {\n    display: 'table',\n    margin: theme.spacing(1),\n  },\n  checkResult: {\n    marginBottom: theme.spacing(2),\n  },\n}));\n\nconst CheckJsonTab: React.FunctionComponent<{}> = () => {\n  const classes = useStyles();\n  const [jsonValue, setJsonValue] = React.useState(defaultValue);\n  const [result, setResult] = React.useState<JsonLdCheckResult>();\n\n  const onChange = (value: string) => {\n    setResult(undefined);\n    setJsonValue(value);\n  };\n\n  return (\n    <>\n      <div className={classes.buttonWrapper}>\n        <CheckJsonButton value={jsonValue} setResult={setResult} />\n        <JsonLdPlaygroundButton value={jsonValue} />\n      </div>\n      <div className={classes.contentWrapper}>\n        <CheckResult className={classes.checkResult} result={result} />\n        <JsonEditor onChange={onChange} value={jsonValue} />\n      </div>\n    </>\n  );\n};\n\nexport default CheckJsonTab;\n","import React from 'react';\nimport { makeStyles } from '@material-ui/core/styles';\nimport Box from '@material-ui/core/Box';\nimport Collapse from '@material-ui/core/Collapse';\nimport IconButton from '@material-ui/core/IconButton';\nimport Table from '@material-ui/core/Table';\nimport TableBody from '@material-ui/core/TableBody';\nimport TableCell from '@material-ui/core/TableCell';\nimport TableContainer from '@material-ui/core/TableContainer';\nimport TableHead from '@material-ui/core/TableHead';\nimport TableRow from '@material-ui/core/TableRow';\nimport Typography from '@material-ui/core/Typography';\nimport Paper from '@material-ui/core/Paper';\nimport KeyboardArrowDownIcon from '@material-ui/icons/KeyboardArrowDown';\nimport KeyboardArrowUpIcon from '@material-ui/icons/KeyboardArrowUp';\nimport Done from '@material-ui/icons/Done';\nimport Error from '@material-ui/icons/Error';\nimport HourglassEmpty from '@material-ui/icons/HourglassEmpty';\nimport JsonEditor from './JsonEditor';\nimport CheckResult from './CheckResult';\nimport CheckStatus from '../models/CheckStatus';\n\nconst useRowStyles = makeStyles({\n  root: {\n    '& > *': {\n      borderBottom: 'unset',\n    },\n  },\n});\n\nfunction Row(props: { row: any }) {\n  const { row } = props;\n  const [open, setOpen] = React.useState(false);\n  const classes = useRowStyles();\n  let Icon;\n  switch (row.status) {\n    case CheckStatus.PASSED:\n      Icon = <Done style={{ color: 'green' }} />;\n      break;\n    case CheckStatus.FAILED:\n      Icon = <Error style={{ color: 'red' }} />;\n      break;\n    case CheckStatus.PENDING:\n    default:\n      Icon = <HourglassEmpty style={{ color: 'orange' }} />;\n  }\n\n  return (\n    <>\n      <TableRow className={classes.root}>\n        <TableCell>\n          <IconButton\n            aria-label=\"expand row\"\n            size=\"small\"\n            onClick={() => setOpen(!open)}\n          >\n            {open ? <KeyboardArrowUpIcon /> : <KeyboardArrowDownIcon />}\n          </IconButton>\n        </TableCell>\n        <TableCell component=\"th\" scope=\"row\">\n          {row.name}\n        </TableCell>\n        <TableCell align=\"center\">{Icon}</TableCell>\n      </TableRow>\n      <TableRow>\n        <TableCell style={{ paddingBottom: 0, paddingTop: 0 }} colSpan={6}>\n          <Collapse in={open} timeout=\"auto\" unmountOnExit>\n            <Box margin={1}>\n              <Typography variant=\"h6\" gutterBottom component=\"div\">\n                Details\n              </Typography>\n              <CheckResult result={row.result} />\n              <JsonEditor\n                value={JSON.stringify(row.object, null, 2)}\n                index={row.key}\n                readOnly\n              />\n            </Box>\n          </Collapse>\n        </TableCell>\n      </TableRow>\n    </>\n  );\n}\n\nconst ResultTable: React.FunctionComponent<{ results: Array<Object> }> = ({\n  results,\n}) => {\n  const rows = results.map(\n    ({ object, status, error, result }: any, index: number) => ({\n      key: index,\n      name: object.id ? object.id : `object ${index}`,\n      status,\n      object,\n      error,\n      result,\n    })\n  );\n  if (rows.length === 0) {\n    return <></>;\n  }\n  return (\n    <TableContainer component={Paper}>\n      <Table aria-label=\"collapsible table\">\n        <TableHead>\n          <TableRow>\n            <TableCell />\n            <TableCell>JSON-LD objects detected</TableCell>\n            <TableCell align=\"center\">Status</TableCell>\n          </TableRow>\n        </TableHead>\n        <TableBody>\n          {rows.map((row) => (\n            <Row key={row.key} row={row} />\n          ))}\n        </TableBody>\n      </Table>\n    </TableContainer>\n  );\n};\n\nexport default ResultTable;\n","/* eslint-disable no-await-in-loop */\n/* eslint-disable no-restricted-syntax */\nimport Button from '@material-ui/core/Button';\nimport LinearProgress from '@material-ui/core/LinearProgress';\nimport { makeStyles } from '@material-ui/core/styles';\nimport TextField from '@material-ui/core/TextField';\nimport { Alert, AlertTitle } from '@material-ui/lab';\nimport { check, getAllJsonLdFromString } from 'jsonld-checker';\nimport React from 'react';\nimport CheckStatus from '../models/CheckStatus';\nimport ResultTable from './ResultTable';\n\nconst defaultUrl =\n  'https://raw.githubusercontent.com/transmute-industries/universal-wallet/master/docs/index.html';\n\nconst useStyles = makeStyles((theme) => ({\n  root: {\n    display: 'flex',\n    flexWrap: 'wrap',\n  },\n  progressBar: {\n    width: '100%',\n    marginTop: theme.spacing(2),\n    marginBottom: theme.spacing(2),\n  },\n  textField: {\n    marginLeft: theme.spacing(1),\n    marginRight: theme.spacing(1),\n    width: '25ch',\n  },\n}));\n\nconst CheckFileTab: React.FunctionComponent<{}> = () => {\n  const [url, setUrl] = React.useState(defaultUrl);\n  const [docs, setDocs] = React.useState<Array<any>>([]);\n  const [total, setTotal] = React.useState<number>(0);\n\n  const onClickCheck = async () => {\n    const res = await fetch(url);\n    const text = await res.text();\n    const jsonldObjects: Array<any> = await getAllJsonLdFromString(text);\n    setTotal(jsonldObjects.length);\n    const sleep = (ms: number) =>\n      new Promise((resolve) => setTimeout(resolve, ms));\n    const processed = [];\n    for (let i = 0; i < jsonldObjects.length; i += 1) {\n      const object = jsonldObjects[i];\n      await sleep(200);\n      const result = await check(object);\n      processed.push({\n        object,\n        status: result.ok ? CheckStatus.PASSED : CheckStatus.FAILED,\n        error: result.error,\n        result,\n      });\n      setDocs([...processed]);\n    }\n  };\n\n  const onChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    setUrl(event.target.value);\n  };\n\n  const classes = useStyles();\n\n  const errors = docs.filter((doc) => doc.status === CheckStatus.FAILED);\n  const hasErrors = errors.length > 0;\n  const errorSentence = `Found ${errors.length} JSON-LD errors`;\n\n  return (\n    <div className={classes.root}>\n      <Button variant=\"contained\" color=\"primary\" onClick={onClickCheck}>\n        Check\n      </Button>\n      <TextField\n        label=\"Enter the URL to a file\"\n        onChange={onChange}\n        defaultValue={defaultUrl}\n        style={{ margin: 8 }}\n        fullWidth\n        margin=\"normal\"\n      />\n      {hasErrors ? (\n        <Alert severity=\"error\">\n          <AlertTitle>{errorSentence}</AlertTitle>\n          Check details below\n        </Alert>\n      ) : (\n        <></>\n      )}\n      {total > 0 ? (\n        <div className={classes.progressBar}>\n          <LinearProgress\n            variant=\"determinate\"\n            value={(100 * docs.length) / total}\n          />\n        </div>\n      ) : (\n        <></>\n      )}\n      <ResultTable results={docs} />\n    </div>\n  );\n};\n\nexport default CheckFileTab;\n","import React, { ChangeEvent } from 'react';\nimport { makeStyles } from '@material-ui/core/styles';\nimport AppBar from '@material-ui/core/AppBar';\nimport Tabs from '@material-ui/core/Tabs';\nimport Tab from '@material-ui/core/Tab';\nimport Box from '@material-ui/core/Box';\nimport CheckJsonTab from './CheckJsonTab';\nimport CheckFileTab from './CheckFileTab';\n\ntype TabPanelProps = {\n  children: React.ReactNode;\n  value: number;\n  index: number;\n};\n\nfunction TabPanel(props: TabPanelProps) {\n  const { children, value, index } = props;\n\n  return (\n    <div\n      role=\"tabpanel\"\n      hidden={value !== index}\n      id={`simple-tabpanel-${index}`}\n      aria-labelledby={`simple-tab-${index}`}\n    >\n      {value === index && <Box p={3}>{children}</Box>}\n    </div>\n  );\n}\n\nfunction a11yProps(index: number) {\n  return {\n    id: `simple-tab-${index}`,\n    'aria-controls': `simple-tabpanel-${index}`,\n  };\n}\n\nconst useStyles = makeStyles((theme) => ({\n  root: {\n    flexGrow: 1,\n    backgroundColor: theme.palette.background.paper,\n  },\n}));\n\nexport default function SimpleTabs() {\n  const classes = useStyles();\n  const [value, setValue] = React.useState(0);\n\n  const handleChange = (event: ChangeEvent<{}>, newValue: number) => {\n    if (newValue === 2) {\n      alert('Not implemented yet');\n    } else {\n      setValue(newValue);\n    }\n  };\n\n  return (\n    <div className={classes.root}>\n      <AppBar position=\"static\">\n        <Tabs value={value} onChange={handleChange} centered>\n          <Tab label=\"Check a single JSON\" {...a11yProps(0)} />\n          <Tab label=\"Check a file\" {...a11yProps(1)} />\n          <Tab label=\"Check a Github repo\" {...a11yProps(2)} />\n        </Tabs>\n      </AppBar>\n      <TabPanel value={value} index={0}>\n        <CheckJsonTab />\n      </TabPanel>\n      <TabPanel value={value} index={1}>\n        <CheckFileTab />\n      </TabPanel>\n      <TabPanel value={value} index={2}>\n        <div>TODO</div>\n      </TabPanel>\n    </div>\n  );\n}\n","import React from 'react';\nimport Tabs from './components/Tabs';\n\nfunction App() {\n  return <Tabs />;\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport './index.css';\n\nconsole.log(`Current commit is ${process.env.REACT_APP_CURRENT_COMMIT}`);\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","class CheckResult {\n  ok: boolean;\n\n  error?: {\n    type: string;\n    details: string;\n  };\n\n  constructor(ok: boolean, type = '', details = '') {\n    this.ok = ok;\n    this.error = {\n      type,\n      details,\n    };\n  }\n}\n\nexport default CheckResult;\n","import jsonld from 'jsonld';\nimport CheckResult from './CheckResult';\n\nconst CONTEXTS = {};\n\n// From https://github.com/flexdinesh/browser-or-node/blob/master/src/index.js\nconst isNode =\n  typeof process !== 'undefined' &&\n  process.versions != null &&\n  process.versions.node != null;\n\nconst nodeDocumentLoader = isNode\n  ? jsonld.documentLoaders.node()\n  : jsonld.documentLoaders.xhr();\n\n// change the default document loader\nconst customLoader = async (url: string) => {\n  if (url in CONTEXTS) {\n    return {\n      contextUrl: null,\n      document: CONTEXTS[url],\n      documentUrl: url,\n    };\n  }\n  const res = await nodeDocumentLoader(url);\n  CONTEXTS[url] = res.document;\n  return res;\n};\n\njsonld.documentLoader = customLoader;\n\nconst isNotJsonLdPropery = property => !['@id', '@type'].includes(property);\n\nexport const check = async (jsonldDocument: string | object) => {\n  try {\n    let jsonldDoc: object;\n    if (typeof jsonldDocument === 'string') {\n      jsonldDoc = JSON.parse(jsonldDocument);\n    } else {\n      jsonldDoc = jsonldDocument;\n    }\n    // Remove all keys not present in the jsonld context\n    const expanded = await jsonld.expand(jsonldDoc);\n    const compacted = await jsonld.compact(expanded, jsonldDoc['@context']);\n    // Check which keys have been removed\n    const keys = Object.keys(jsonldDoc).filter(isNotJsonLdPropery);\n    const newKeysSet = new Set(Object.keys(compacted));\n    const difference = keys.filter(key => !newKeysSet.has(key));\n    if (difference.length === 0) {\n      return new CheckResult(true);\n    }\n    return new CheckResult(\n      false,\n      'MISSING_PROPERTIES_IN_CONTEXT',\n      JSON.stringify(difference)\n    );\n  } catch (err) {\n    return new CheckResult(false, err.name, err.message);\n  }\n};\n\nconst getAllOpenBrackets = (text: string) => {\n  const results: number[] = [];\n  for (let cursor = 0; cursor < text.length; cursor += 1) {\n    if (text[cursor] === '{') {\n      results.push(cursor);\n    }\n  }\n  return results;\n};\n\nconst getStringUntilMatchingBracket = (\n  text: string,\n  openBracketIndex: number\n) => {\n  let substring = text[openBracketIndex];\n  if (substring !== '{') {\n    throw new Error('start must be the index of an opening bracket');\n  }\n  let bracketCount = 1;\n  let cursor = openBracketIndex + 1;\n  const { length } = text;\n  while (bracketCount !== 0 && cursor < length) {\n    const currentChar = text[cursor];\n    if (currentChar === '{') {\n      bracketCount += 1;\n    } else if (currentChar === '}') {\n      bracketCount -= 1;\n    }\n    cursor += 1;\n    substring += currentChar;\n  }\n  try {\n    return JSON.parse(substring);\n  } catch (e) {\n    return null;\n  }\n};\n\nexport const getAllJsonFromString = (text: string): Array<Object> => {\n  const openBrackets = getAllOpenBrackets(text);\n  return openBrackets\n    .map(openBracketIndex =>\n      getStringUntilMatchingBracket(text, openBracketIndex)\n    )\n    .filter(Boolean);\n};\n\nexport const isJsonLdObject = (obj: Object): Boolean => {\n  return '@context' in obj;\n};\n\nexport const getAllJsonLdFromString = (text: string) => {\n  return getAllJsonFromString(text).filter(obj => isJsonLdObject(obj));\n};\n\nexport { CheckResult };\n"],"sourceRoot":""}